# A simple implementation of RFC 6238.
#
#    totp = TOTP.new(Base32.encode('12345678901234567890'))
#    otp = totp.at(Time.gm(1970, 1, 1, 0, 0, 0))
#    totp.verify(otp, :at => 42)
class TOTP < HOTP
  # Default interval (in seconds) used to calculate the time steps since Epoch.
  DEFAULT_INTERVAL = 30
  # Default digest algorithm.
  DEFAULT_DIGEST = 'sha1'

  ##
  # call-seq:
  #    TOTP.new(string)                                                         -> obj
  #    TOTP.new(string, :digits => int, :interval => int, :digest => string)    -> obj
  #
  # Returns the OTP generator object.
  #
  # +secret+ must be a base32 encoded string.
  #
  # Optional <tt>:digits</tt> controls the length of the OTPs generated by
  # this object.
  #
  # Optional <tt>:interval</tt> alters the way time steps are calculated.
  #
  # Optional <tt>:digest</tt> permits the selection of a different digest
  # algoritm; supported values are +sha1+, +SHA1+, +sha256+, +SHA256+,
  # +sha512+ and +SHA512+.
  def initialize secret, options = {}
    super
    @interval = options[:interval] || DEFAULT_INTERVAL
    @digest = options[:digest] || DEFAULT_DIGEST
    @type = 'totp'
  end

  ##
  # call-seq:
  #    otp_generator.at(timestamp)                   -> obj
  #    otp_generator.at(int)                         -> obj
  #    otp_generator.at(int, :padding => boolean)    -> obj
  #
  # Calculates the OTP for +timestamp+ (which can be an instance of Time or an
  # integer representing the number of seconds since Epoch).
  #
  # The generated OTPs are normally padded with "0" if they are shorter than
  # the required length; this behavior can be controlled with
  # <tt>:padding</tt> (default value: +true+).
  def at timestamp, options = {}
    opts = {:padding => true}.merge(options)
    count = timestamp_to_count timestamp
    super count, :padding => opts[:padding]
  end

  ##
  # call-seq:
  #    otp_generator.current                         -> obj
  #    otp_generator.current(:padding => boolean)    -> obj
  #
  # Calculates the OTP for the system's current time.
  #
  # The generated OTPs are normally padded with "0" if they are shorter than
  # the required length; this behavior can be controlled with
  # <tt>:padding</tt> (default value: +true+).
  def current options = {}
    opts = {:padding => true}.merge(options)
    self.at Time.now, :padding => opts[:padding]
  end

  ##
  # call-seq:
  #    otp_generator.verify(string)                                                    -> obj
  #    otp_generator.verify(string, :at => int, :padding => boolean, :drift => int)    -> obj
  #
  # Compare <tt>input_token</tt>, submitted by the user, with the OTP
  # generated for <tt>:at</tt> (default value: <tt>Time.now</tt>); both the
  # submitted token and the calculated one can be zero-padded or not,
  # depending on the value of <tt>:padding</tt> (default value: +true+)
  #
  # User and server's clocks can be out-of-sync; with <tt>:drift</tt> you can
  # specify the number of seconds they're allowed to differ.
  def verify input_token, options = {}
    opts = {:at => Time.now, :padding => true, :drift => nil}.merge(options)
    if opts[:drift] && opts[:drift].to_i.abs > 0
      tp = opts[:at].to_i
      drift = opts[:drift].to_i.abs
      times = (tp - drift).step((tp + drift), @interval).to_a
      times << (tp + drift) if times.last < (tp + drift)
      times.any? {|ts| super input_token, :at => ts, :padding => opts[:padding]}
    else
      super input_token, opts
    end
  end

  private

  def timestamp_to_count timestamp
    (Time.at(timestamp.to_i).utc.to_i / @interval.to_i).floor
  end

  def map_to_digest digest_name
    case digest_name
    when 'sha256', 'SHA256'
      Digest::SHA256
    when 'sha512', 'SHA512'
      Digest::SHA512
    else
      super
    end
  end

  def extra_uri_parameters options
    {'period' => @interval}
  end
end
